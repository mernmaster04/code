import java.text.SimpleDateFormat;  // SimpleDateFormat is used to convert date/time in milliseconds into a human-readable format like
import java.util.*;          //  imports all utility classes like Date, which is used here.

public class BerkeleyAlgorithm {   // This is the main class that contains the Berkeley clock synchronization algorithm.

// Defines a Node (either master or slave), which has a clock time in milliseconds.
    static class Node {
        long clockTime; // Variable store current Time of node (like master or slave) in milliseconds

        public Node(long time) {   // (constructor) Initializes the node's clock with a given time. 
            this.clockTime = time;
        }

        public long getTime() {   //  Getter Method -> Returns the current clock time (in milliseconds) of the node. 
            return clockTime;
        }

        public void setTime(long newTime) {  //  Setter Method: -> Sets (updates) the node's clock time.
            this.clockTime = newTime;
        }

    // Converts the time (in milliseconds) into a human-readable format like "14:25:30:123".
        public String getFormattedTime() {   
            SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss:SSS");
            return sdf.format(new Date(clockTime));
        }
    }

    public static void main(String[] args) {   // This is the entry point of the program.
        // Simulate current time
        long baseTime = System.currentTimeMillis();  // Gets the current time in milliseconds (1714904500000) from the system clock

        // Create nodes with some simulated drift
        Node master = new Node(baseTime); // Creates the master node with the current time of system.

        // Declares an array named slaves, which can hold multiple Node objects.
        Node[] slaves = {   // Creates 3 slave nodes with time drift:
                new Node(baseTime - 200), // 200 ms behind from current time
                new Node(baseTime + 100), // 100 ms min ahead
                new Node(baseTime - 300) // 300 ms behind
        };

        // Display initial times
        System.out.println("Initial Times:");
        System.out.println("Master: " + master.getFormattedTime());
        for (int i = 0; i < slaves.length; i++) {
            System.out.println("Slave " + (i + 1) + ": " + slaves[i].getFormattedTime() +
                    " (Diff: " + (slaves[i].getTime() - master.getTime()) + " ms)");
        }

        // Step 1: Master polls slaves and collects their times
        // Master collects the times of all slave nodes and stores them in an array.
        long[] slaveTimes = new long[slaves.length];
        for (int i = 0; i < slaves.length; i++) {
            slaveTimes[i] = slaves[i].getTime();
        }

        // Step 2: Master calculates offset from its time for each slave
        // Calculates the time difference (offset) of each slave from the master and adds it up.
        long sumOffsets = 0;
        for (long time : slaveTimes) {
            sumOffsets += (time - master.getTime());
        }

        // Average offset including master
        long avgOffset = sumOffsets / (slaves.length + 1);
        System.out.println("\nCalculated Average Offset: " + avgOffset + " ms");

        // Step 3: Compute synchronized time and apply it to all nodes
        long synchronizedTime = master.getTime() + avgOffset;
        master.setTime(synchronizedTime);
        for (Node slave : slaves) {
            slave.setTime(synchronizedTime);
        }

        // Display synchronized times
        System.out.println("\nSynchronized Times:");
        System.out.println("Master: " + master.getFormattedTime());
        for (int i = 0; i < slaves.length; i++) {
            System.out.println("Slave " + (i + 1) + ": " + slaves[i].getFormattedTime() +
                    " (Now aligned)");
        }
    }
}

/*
1. Offset is the difference in time between a slave node’s clock and the master’s clock. (e.g 200ms)

*/
